Part A: Implementing Admin Role-Based Access
First, we need to make sure that only an "admin" (you) can add products. We can't show the "Admin Panel" button to every user.
Step 1: Update signup_screen.dart (to Assign Roles)
When a new user signs up, we'll automatically give them a "user" role in our Firestore database.
lib/screens/signup_screen.dart - Part 1: Imports & Instances
Let's add the cloud_firestore import and get an instance of it inside our _SignUpScreenState.

// ... (other imports)
import 'package:firebase_auth/firebase_auth.dart';
import 'package:cloud_firestore/cloud_firestore.dart'; // 1. ADD THIS IMPORT
// ... (class SignUpScreen)
class _SignUpScreenState extends State<SignUpScreen> {
  // ... (_formKey, controllers, _isLoading)
  final FirebaseAuth _auth = FirebaseAuth.instance;
  final FirebaseFirestore _firestore = FirebaseFirestore.instance; // 2. ADD THIS 
  // ... (dispose method)

1.	import 'package:cloud_firestore/cloud_firestore.dart'; gives us access to all the Firestore database commands.
2.	final FirebaseFirestore _firestore = ... creates an instance of the Firestore service, just like we have one for _auth.



lib/screens/signup_screen.dart - Part 2: The _signUp Function
Now, we'll modify the _signUp function. After the user is successfully created, we'll also create a document for them in a new users collection.

 Future<void> _signUp() async {
    // 1. This part is the same: validate the form
    if (!_formKey.currentState!.validate()) {
      return;
    }
    // 2. This is the same: set loading to true
    setState(() {
      _isLoading = true;
    });

    try {
      // 3. This is the same: create the user
      final UserCredential userCredential = 
          await _auth.createUserWithEmailAndPassword(
        email: _emailController.text.trim(),
        password: _passwordController.text.trim(),
      );

      // 4. --- THIS IS THE NEW PART ---
      // After creating the user, save their info to Firestore
      if (userCredential.user != null) {
        // 5. Create a document in a 'users' collection
        //    We use the user's unique UID as the document ID
        await _firestore.collection('users').doc(userCredential.user!.uid).set({
          'email': _emailController.text.trim(),
          'role': 'user', // 6. Set the default role to 'user'
          'createdAt': FieldValue.serverTimestamp(), // For our records
        });
      }
      // 7. The AuthWrapper will handle navigation automatically
      // ...

    } on FirebaseAuthException catch (e) {
      // ... (your existing error handling)
    } finally {
      if(mounted) {
        setState(() {
          _isLoading = false;
        });
      }
    }
  }

4. We add a new block of code after createUserWithEmailAndPassword is successful. 
5. _firestore.collection('users').doc(userCredential.user!.uid): This command says "In Firestore, find the users collection. Inside it, find the document with this specific uid." 
6. .set({...}): This creates the document (or overwrites it) with the data we provide. We're saving their email and, most importantly, setting their role to 'user'.

Step 2: Manually Make Yourself an "Admin"
Your app now assigns everyone the 'user' role. For security, you must manually promote yourself to an admin from the Firebase Console.
1.	Run your app and sign up for a new account with your own email.
2.	Go to your Firebase Console -> Build -> Firestore Database.
3.	You will see a new users collection. Click it.
4.	You will see a document with your User ID. Click on it.
5.	You will see the fields you just saved. Find the role field.
6.	Click the "edit" icon and change the value from "user" to "admin".
7.	Click the Update button.
Now, your account has the "admin" role, but everyone else who signs up will be a "user"
Step 3: Update home_screen.dart (The "Gatekeeper")
Now, we'll make the HomeScreen check the user's role. If their role is 'admin', we show the "Admin Panel" button. If not, we hide it. This requires converting HomeScreen to a StatefulWidget to fetch and store the role.
lib/screens/home_screen.dart - Part 1: Imports & Class Definition
We'll change the StatelessWidget to a StatefulWidget.
// ... (imports)
import 'package:cloud_firestore/cloud_firestore.dart'; // 1. ADD THIS IMPORT
import 'package:ecommerce_app/screens/admin_panel_screen.dart'; // 2. ADD THIS
// 3. Change StatelessWidget to StatefulWidget
class HomeScreen extends StatefulWidget {
  const HomeScreen({super.key});
  @override
  // 4. Create the State class
  State<HomeScreen> createState() => _HomeScreenState();
}
// 5. Rename the main class to _HomeScreenState and extend State
class _HomeScreenState extends State<HomeScreen> {
  // All our logic and UI will go inside this class now
  // ... (The build method will be moved inside here)
}



lib/screens/home_screen.dart - Part 2: State Logic
Let's add the logic inside _HomeScreenState to fetch the user's role when the screen loads.
class _HomeScreenState extends State<HomeScreen> {
  // 1. A state variable to hold the user's role. Default to 'user'.
  String _userRole = 'user';
  // 2. Get the current user from Firebase Auth
  final User? _currentUser = FirebaseAuth.instance.currentUser;
  // 3. This function runs ONCE when the screen is first created
  @override
  void initState() {
    super.initState();
    // 4. Call our function to get the role as soon as the screen loads
    _fetchUserRole();
  }

  // 5. This is our new function to get data from Firestore
  Future<void> _fetchUserRole() async {
    // 6. If no one is logged in, do nothing
    if (_currentUser == null) return;
    try {
      // 7. Go to the 'users' collection, find the document
      //    matching the current user's ID
      final doc = await FirebaseFirestore.instance
          .collection('users')
          .doc(_currentUser!.uid)
          .get();
      
      // 8. If the document exists...
      if (doc.exists && doc.data() != null) {
        // 9. ...call setState() to save the role to our variable
        setState(() {
          _userRole = doc.data()!['role'];
        });
      }
    } catch (e) {
      print("Error fetching user role: $e");
      // If there's an error, they'll just keep the 'user' role
    }
  }
  // 10. Move the _signOut function inside this class
  Future<void> _signOut() async {
    try {
      await FirebaseAuth.instance.signOut();
    } catch (e) {
      print('Error signing out: $e');
    }
  }
  // The build method is next...
●	_userRole: A variable in our State to remember the role.
●	initState(): A special function that runs once when the widget is first built. It's the perfect place to start a data fetch.
●	_fetchUserRole(): This async function queries our users collection for the one document matching the logged-in user's ID.
●	setState(() { _userRole = ... }): This is the most important part. When the data arrives, setState rebuilds the widget and updates _userRole, which will make our admin button appear.





lib/screens/home_screen.dart - Part 3: The build Method
Finally, we modify the build method (which is now inside _HomeScreenState) to conditionally show the button.
 @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        // 1. Use the _currentUser variable we defined
        title: Text(_currentUser != null ? 'Welcome, ${_currentUser!.email}' : 'Home'),
        actions: [
          
          // 2. --- THIS IS THE MAGIC ---
          //    This is a "collection-if". The IconButton will only
          //    be built IF _userRole is equal to 'admin'.
          if (_userRole == 'admin')
            IconButton(
              icon: const Icon(Icons.admin_panel_settings),
              tooltip: 'Admin Panel',
              onPressed: () {
                // 3. This is why we imported admin_panel_screen.dart
                Navigator.of(context).push(
                  MaterialPageRoute(
                    builder: (context) => const AdminPanelScreen(),
                  ),
                );
              },
            ),
          
          // 4. The logout button (always visible)
          IconButton(
            icon: const Icon(Icons.logout),
            tooltip: 'Logout',
            onPressed: _signOut, // 5. Call our _signOut function
          ),
        ],
      ),
      body: const Center(
        child: Text(
          'This is the Home Screen. Products will be listed here!',
          style: TextStyle(fontSize: 18),
        ),
      ),
    );
  }
}
●	if (_userRole == 'admin'): This is a conditional if inside the actions: [] list. Flutter is smart enough to know that if this condition is false, it should just skip building the IconButton.

Part B: Building the Admin Panel (with URL)
Now we'll create the admin_panel_screen.dart file. Only admins can reach this screen, but it doesn't exist yet!
Step 1: Enable Firestore (if not already done)
●	You should have already done this in Part A, but if not: Go to Firebase Console -> Firestore Database -> "Create database" -> "Start in test mode".
Step 2: Create lib/screens/admin_panel_screen.dart (New File)
This file will contain the form for adding products.
lib/screens/admin_panel_screen.dart - Part 1: Imports & State Variables
import 'package:flutter/material.dart';
import 'package:cloud_firestore/cloud_firestore.dart';

class AdminPanelScreen extends StatefulWidget {
  const AdminPanelScreen({super.key});

  @override
  State<AdminPanelScreen> createState() => _AdminPanelScreenState();
}

class _AdminPanelScreenState extends State<AdminPanelScreen> {
  // 1. A key to validate our Form
  final _formKey = GlobalKey<FormState>();

  // 2. Controllers for each text field
  final _nameController = TextEditingController();
  final _descriptionController = TextEditingController();
  final _priceController = TextEditingController();
  final _imageUrlController = TextEditingController(); // For the image link

  // 3. A variable to show a loading spinner
  bool _isLoading = false;

  // 4. An instance of Firestore to save data
  final FirebaseFirestore _firestore = FirebaseFirestore.instance;

  // 5. Clean up the controllers
  @override
  void dispose() {
    _nameController.dispose();
    _descriptionController.dispose();
    _priceController.dispose();
    _imageUrlController.dispose();
    super.dispose();
  }
  
  // The upload logic will go here next...

●	This is a StatefulWidget because we need to manage the text in the controllers and the _isLoading state.
●	We create a TextEditingController for each field we want to manage.
●	_imageUrlController is the controller for our new "Image URL" text field.
lib/screens/admin_panel_screen.dart - Part 2: The _uploadProduct Function
This function runs when the admin taps the "Upload" button.

 Future<void> _uploadProduct() async {
    // 1. First, check if all form fields are valid
    if (!_formKey.currentState!.validate()) {
      return; // If not, do nothing
    }

    // 2. Show the loading spinner
    setState(() {
      _isLoading = true;
    });

    try {
      // 3. Get the text from our URL controller
      String imageUrl = _imageUrlController.text.trim();

      // 4. Add the data to a new 'products' collection
      await _firestore.collection('products').add({
        'name': _nameController.text.trim(),
        'description': _descriptionController.text.trim(),
        // 5. Try to parse the price text as a number
        'price': double.tryParse(_priceController.text.trim()) ?? 0.0,
        'imageUrl': imageUrl, // 6. Save the URL string
        'createdAt': FieldValue.serverTimestamp(),
      });

      // 7. If successful, show a confirmation message
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Product uploaded successfully!')),
      );
      
      // 8. Clear all the text fields
      _formKey.currentState!.reset();
      _nameController.clear();
      _descriptionController.clear();
      _priceController.clear();
      _imageUrlController.clear();

    } catch (e) {
      // 9. If something went wrong, show an error
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('Failed to upload product: $e')),
      );
    } finally {
      // 10. ALWAYS hide the loading spinner
      if (mounted) {
        setState(() {
          _isLoading = false;
        });
      }
    }
  }
1.	_formKey.currentState!.validate(): This runs the validator function on every TextFormField in our form.
2.	setState(() { _isLoading = true; }): This rebuilds the widget to show the loading spinner.
3.	_firestore.collection('products').add({...}): This is the core command. It goes to our products collection and adds a new document with all the data from our text controllers.
4.	double.tryParse(...): This safely converts the price (which is String) into a double (a number). If it fails, it defaults to 0.0.
5.	finally { ... }: This block of code runs no matter what (whether the try succeeded or the catch failed). It's the perfect place to hide our spinner.

lib/screens/admin_panel_screen.dart - Part 3: The build Method (UI)
This is the final piece—the layout of the admin form.
 @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Admin - Add Product'),
      ),
      // 1. Lets the user scroll if the keyboard covers the fields
      body: SingleChildScrollView(
        child: Padding(
          padding: const EdgeInsets.all(16.0),
          // 2. The Form widget that holds our fields
          child: Form(
            key: _formKey, // 3. Link the form to our key
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.stretch,
              children: [
                
                // 4. The "Image URL" text field
                TextFormField(
                  controller: _imageUrlController,
                  decoration: const InputDecoration(labelText: 'Image URL'),
                  keyboardType: TextInputType.url,
                  validator: (value) {
                    if (value == null || value.isEmpty) {
                      return 'Please enter an image URL';
                    }
                    if (!value.startsWith('http')) {
                      return 'Please enter a valid URL (e.g., http://...)';
                    }
                    return null;
                  },
                ),
                const SizedBox(height: 16),
                
                // 5. The "Product Name" text field
                TextFormField(
                  controller: _nameController,
                  decoration: const InputDecoration(labelText: 'Product Name'),
                  validator: (value) =>
                      value!.isEmpty ? 'Please enter a name' : null,
                ),
                const SizedBox(height: 16),

                // 6. The "Description" text field
                TextFormField(
                  controller: _descriptionController,
                  decoration: const InputDecoration(labelText: 'Description'),
                  maxLines: 3, // Makes the field taller
                  validator: (value) =>
                      value!.isEmpty ? 'Please enter a description' : null,
                ),
                const SizedBox(height: 16),
                
                // 7. The "Price" text field
                TextFormField(
                  controller: _priceController,
                  decoration: const InputDecoration(labelText: 'Price'),
                  keyboardType: TextInputType.number, // Shows number keyboard
                  validator: (value) {
                    if (value == null || value.isEmpty) {
                      return 'Please enter a price';
                    }
                    if (double.tryParse(value) == null) {
                      return 'Please enter a valid number';
                    }
                    return null;
                  },
                ),
                const SizedBox(height: 20),
                
                // 8. The "Upload" Button
                ElevatedButton(
                  style: ElevatedButton.styleFrom(
                    padding: const EdgeInsets.symmetric(vertical: 16),
                  ),
                  // 9. If loading, disable the button
                  onPressed: _isLoading ? null : _uploadProduct,
                  // 10. If loading, show spinner, else show text
                  child: _isLoading
                      ? const CircularProgressIndicator()
                      : const Text('Upload Product'),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }

●	SingleChildScrollView: This is a key widget that prevents the "bottom overflow" error when you open the keyboard on a small screen.
●	Form: This widget wraps all our TextFormFields.
●	TextFormField: Each field has:
○	controller: Links it to our state variable (e.g., _nameController).
○	decoration: Makes it look nice with a label.
○	validator: The function that runs when _formKey.currentState!.validate() is called. It returns null if valid, or an error string if invalid.
●	ElevatedButton Logic: The onPressed and child properties use a ternary operator (? :) to check the _isLoading variable. This is how you show a loading state on a button.

Expected Output
1.	Full Restart your app.
2.	Log in as a normal 'user': You will see the HomeScreen, but the "Admin Panel" icon in the AppBar will be hidden.
3.	Log out.
4.	Log in as your 'admin' account: You will see the HomeScreen, and the "Admin Panel" icon will be visible.
5.	Tap the admin icon: You will be navigated to the "Admin - Add Product" screen.
6.	Find an image URL: Go to Google, right-click an image, and "Copy Image Address".
7.	Test the form: Paste the URL and fill out the other fields. Tap "Upload Product".
8.	Result: The button will show a spinner, then you'll get a "Product uploaded successfully!" message, and the fields will clear.
9.	Check Firestore: Go to your Firebase Console. You will see a new products collection with your new product (and its URL) saved inside.

