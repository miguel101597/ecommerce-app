Right now, our CartProvider stores items in a local list in the app's memory. This is bad because if the user closes the app, their cart is gone.
In this module, we'll fix this by syncing the cart with a Firestore collection. The cart will be tied to the user's ID.
1.	When a user logs in, we'll automatically fetch their saved cart from Firestore.
2.	When a user adds/removes an item, we'll save the new cart back to Firestore.
3.	When a user logs out, we'll clear the local cart.
The best part? Thanks to our Provider architecture, almost all of our changes will be in lib/providers/cart_provider.dart. Our UI screens won't need to change at all!

Update CartItem Model (for Firestore)
Firestore stores data as Maps (like JSON). We need to teach our CartItem class how to convert itself to and from a Map.
lib/providers/cart_provider.dart - Part 1: CartItem Class
Add these toJson and fromJson methods to your existing CartItem class.

// (This is at the top of lib/providers/cart_provider.dart)

class CartItem {
  final String id;
  final String name;
  final double price;
  int quantity;

  CartItem({
    required this.id,
    required this.name,
    required this.price,
    this.quantity = 1,
  });

  // 1. ADD THIS: A method to convert our CartItem object into a Map
  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'name': name,
      'price': price,
      'quantity': quantity,
    };
  }

  // 2. ADD THIS: A factory constructor to create a CartItem from a Map
  factory CartItem.fromJson(Map<String, dynamic> json) {
    return CartItem(
      id: json['id'],
      name: json['name'],
      price: json['price'],
      quantity: json['quantity'],
    );
  }
}

●	toJson(): This method converts our Dart object into a Map<String, dynamic>, which is the format Firestore understands.
●	CartItem.fromJson(): This is a factory constructor. It does the reverse: it takes a Map (which we'll get from Firestore) and builds a new CartItem object with that data.


Update CartProvider (The "Brain")
Now we'll modify the CartProvider itself.
lib/providers/cart_provider.dart - Part 2: Imports & New Properties
Add new imports for async, firebase_auth, and cloud_firestore at the top of the file. Then, add new properties to your CartProvider class.

import 'dart:async'; // 1. ADD THIS (for StreamSubscription)
import 'package:flutter/foundation.dart';
import 'package:firebase_auth/firebase_auth.dart'; // 2. ADD THIS
import 'package:cloud_firestore/cloud_firestore.dart'; // 3. ADD THIS

// ... (CartItem class)

class CartProvider with ChangeNotifier {
  
  // 4. Change this: _items is no longer final
  List<CartItem> _items = []; 

  // 5. ADD THESE: New properties for auth and database
  String? _userId; // Will hold the current user's ID
  StreamSubscription? _authSubscription; // To listen to auth changes

  // 6. ADD THESE: Get Firebase instances
  final FirebaseAuth _auth = FirebaseAuth.instance;
  final FirebaseFirestore _firestore = FirebaseFirestore.instance;
  
  // ... (getters: items, itemCount, totalPrice are all unchanged)


●	_items = []: We remove the final keyword. This is because we will be completely replacing this list with the one we fetch from Firestore.
●	_userId: This will store who is currently logged in.
●	_authSubscription: When we listen to the auth state, we get a "subscription." We need to save it so we can cancel() it later to prevent memory leaks.
●	_auth & _firestore: We create instances of our Firebase services.

lib/providers/cart_provider.dart - The Constructor
This is the new "brain" of the provider. Add this constructor to your CartProvider class. It will run once when the provider is first created (in main.dart).

 // ... (after the getters)

  // 7. ADD THIS CONSTRUCTOR
  CartProvider() {
    print('CartProvider initialized');
    // Listen to authentication changes
    _authSubscription = _auth.authStateChanges().listen((User? user) {
      if (user == null) {
        // User is logged out
        print('User logged out, clearing cart.');
        _userId = null;
        _items = []; // Clear local cart
      } else {
        // User is logged in
        print('User logged in: ${user.uid}. Fetching cart...');
        _userId = user.uid;
        _fetchCart(); // Load their cart from Firestore
      }
      // Notify listeners to update UI (e.g., clear cart badge on logout)
      notifyListeners();
    });
  }
●	CartProvider(): This is the class constructor.
●	_auth.authStateChanges().listen(...): This is the core of our new logic. We subscribe to the auth stream inside the provider.
●	If user == null: The user just logged out. We set _userId to null and clear the local _items list to an empty array.
●	If user != null: The user just logged in. We save their _userId and immediately call a new function _fetchCart() to load their saved data from the database.
●	notifyListeners(): We call this in both cases to make sure the UI updates (e.g., the cart badge disappears when you log out).

lib/providers/cart_provider.dart - Add _fetchCart & _saveCart
Add these two new private helper functions inside your CartProvider class.

 // 8. ADD THIS: Fetches the cart from Firestore
  Future<void> _fetchCart() async {
    if (_userId == null) return; // Not logged in, nothing to fetch

    try {
      // 1. Get the user's specific cart document
      final doc = await _firestore.collection('userCarts').doc(_userId).get();
      
      if (doc.exists && doc.data()!['cartItems'] != null) {
        // 2. Get the list of items from the document
        final List<dynamic> cartData = doc.data()!['cartItems'];
        
        // 3. Convert that list of Maps into our List<CartItem>
        //    (This is why we made CartItem.fromJson!)
        _items = cartData.map((item) => CartItem.fromJson(item)).toList();
        print('Cart fetched successfully: ${_items.length} items');
      } else {
        // 4. The user has no saved cart, start with an empty one
        _items = [];
      }
    } catch (e) {
      print('Error fetching cart: $e');
      _items = []; // On error, default to an empty cart
    }
    notifyListeners(); // Update the UI
  }

  // 9. ADD THIS: Saves the current local cart to Firestore
  Future<void> _saveCart() async {
    if (_userId == null) return; // Not logged in, nowhere to save

    try {
      // 1. Convert our List<CartItem> into a List<Map>
      //    (This is why we made toJson()!)
      final List<Map<String, dynamic>> cartData = 
          _items.map((item) => item.toJson()).toList();
      
      // 2. Find the user's document and set the 'cartItems' field
      await _firestore.collection('userCarts').doc(_userId).set({
        'cartItems': cartData,
      });
      print('Cart saved to Firestore');
    } catch (e) {
      print('Error saving cart: $e');
    }
  }


●	_fetchCart():
1.	Gets the document from Firestore at the path userCarts/[the_user's_id].
2.	Reads the cartItems field, which is a List of Maps.
3.	Uses our new CartItem.fromJson to .map() the list of data into a List<CartItem>.
4.	Calls notifyListeners() to update the UI (e.g., the cart badge will now show "5" if 5 items were saved).
●	_saveCart():
1.	Does the reverse. It uses item.toJson() to .map() our List<CartItem> into a List<Map<String, dynamic>>.
2.	set({...}) saves this list to the user's document, overwriting whatever was there.
lib/providers/cart_provider.dart - Update addItem & removeItem
This is the easiest step. We just need to add one line to each of these functions.

 void addItem(String id, String name, double price) {
    // ... (all your existing logic is the same)
    var index = _items.indexWhere((item) => item.id == id);
    if (index != -1) {
      _items[index].quantity++;
    } else {
      _items.add(CartItem(id: id, name: name, price: price));
    }

    _saveCart(); // 10. ADD THIS LINE
    notifyListeners();
  }

  void removeItem(String id) {
    // ... (existing logic is the same)
    _items.removeWhere((item) => item.id == id);
    
    _saveCart(); // 11. ADD THIS LINE
    notifyListeners();
  }
●	Now, every time an item is added or removed, we update the local _items list, call notifyListeners() to update the UI, and then we call _saveCart() to sync the change to Firestore.
lib/providers/cart_provider.dart - dispose() Method
We must cancel our stream listener when the app closes to prevent memory leaks.
 // 12. ADD THIS METHOD (or update it if it exists)
  @override
  void dispose() {
    _authSubscription?.cancel(); // Cancel the auth listener
    super.dispose();
  }
}
●	This cleans up our _authSubscription when the CartProvider is no longer needed.

Check Your UI Files (No Changes Needed!)
This is the best part of using a Provider. You do not need to change a single line of code in:
●	lib/screens/home_screen.dart
●	lib/screens/cart_screen.dart
●	lib/screens/product_detail_screen.dart
Why?
●	ProductDetailScreen still just calls cart.addItem(...). It doesn't know or care that this function now also saves to Firestore.
●	HomeScreen and CartScreen still just read cart.items, cart.itemCount, and cart.totalPrice. They will automatically display the items loaded from Firestore because our _fetchCart() function calls notifyListeners() when the data arrives.
The UI is decoupled from the data source. This is excellent architecture.

Expected Output
1.	Full Restart your app.
2.	Log in. You will briefly see the cart badge at "0" (or no badge).
3.	After a split-second, _fetchCart() will complete, and if you had items in your cart from a previous session, the badge will update with the correct count.
4.	Go to the Cart Screen. You should see your items loaded from Firestore.
5.	Add a new item to your cart from a product's detail page.
6.	You should see the "Added to cart!" snackbar.
7.	Completely close and stop the app.
8.	Re-open the app.
9.	The app will load, you'll see your splash screen, and the AuthWrapper will send you to the HomeScreen.
10.	CartProvider's constructor will run, detect you're logged in, and call _fetchCart().
11.	You should see your cart badge correctly displaying the item count from your previous session.
12.	Go to the Cart Screen. All your items are still there!
13.	Now, log out.
14.	You are sent to the LoginScreen. The CartProvider's listener saw you log out, cleared its local list, and the cart badge will be gone.
15.	Log back in (as the same user). The provider will detect the login and re-fetch your cart from Firestore.

